
def custom_write(file_name, strings): #=> объявляем функцию записи файла с параметрами: (file_name - имя создаваемого файла)
                                      # и (strings - список строк)
    st_ = 0 #=> вводим переменную, котрая будет считать номера строк, начальное значение равно нулю
    bt_ = 0 #=> вводим переменную, котрая будет считать байты в строках, начальное значение равно нулю
    strings_positions = {} #=> создаем изначально пустой словарь для вывода информации о строках в соответствии с заданием
    file = open(file_name, "a", encoding = 'utf-8') #=> открываем файл для добавления в него текстовых строк
                                                    # с применением раскодирования кодировкой utf-8
    for i in range(len(strings)): #=> открываем цикл в размере (range) количества строк в списке строк (strings)
        st_ = i + 1 #=> подсчет номера строки
        bt_ = file.tell() #=> подсчет количества байтов в строках с помощью встроенного метода tell
        s_b = (st_,bt_) #=> формирование ключа словаря в виде кортежа из номера строки и количества подсчитанных байтов
        strings_positions[s_b] = strings[i] #=> здесь идёт добавление к i-тому ключу словаря i-ой строки (значения)
        file.write(strings[i]+"\n") #=> перезаписываем файл с новой строкой с новой строки

    file.close() #=> закрываем файл
    return strings_positions #=> возвращаем словарь

info = [
    'Text for tell.',
    'Используйте кодировку utf-8.',
    'Because there are 2 languages!',
    'Спасибо!'
    ] #=> изначальная текстовая информация для подсчета строк и байтов

result = custom_write('test.txt', info) #=> запускаем функцию custom_write с заданными значениями параметров
for elem in result.items(): #=> открываем цикл для перебора элеметов (elem) словаря с помощью встроенного метода
                            # словаря items для возвращения пары: ключ-значение
  print(elem) #=> вывод на консоль элемента